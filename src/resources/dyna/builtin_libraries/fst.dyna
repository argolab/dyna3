:- export fst/1.
:- export epsilon/0.

epsilon = &epsilon

fst(X: dynabase) := fst_dynabase(X).
fst(X: string) := fst_str(X).


% there could be a special semiring argument?  Though we might also want to
fst_dynbase(X) = {
    edge(From, To, InLabel, OutLabel) = X.edge(From, To, InLabel, OutLabel).
    start = X.start.
    end(X) = X.end(X).


    compose(Other) = fst_dynabase {
        % This would still have to handle epsilon labels on the edges, as those could also align together
        edge(&c(FA, FB), &c(TA, TB), InLabel, OutLabel) = Self.edge(FA, TA, InLabel, InterLabel) * Other.edge(FB, TB, InterLabel, OutLabel).
        start = &c(Self.start, Other.start).
        end(&c(A, B)) = Self.end(A) * Other.end(B).
    } for Self=$self.

    num_edges += 1 for _ = $self.edge(_,_,_,_).
    states(X) :- _ = $self.edge(X,_,_,_).
    states(X) :- _ = $self.edge(_,X,_,_).
    states($self.start).
    states(X) :- _ = $self.end(X).
    num_states += 1 for states(X).

    remove_epsilon = fst_dynabase {
        start = Self.start.
        end(X) = Self.end(X).

        node_remove_epsilon(A, A) *= 1.
        node_remove_epsilon(From, To) *= Self.edge(From, T1, epislon, epislon) * $self.node_remove_epsilon(T1, To).
        edge(From, To, IL, OL) = Self.edge(From, T1, IL, OL) * $self.node_remove_epsilon(T1, To) for (IL != epislon || OL != epislon).
    } for Self=$self.

    minimize = fst_dynabase {

    }.
}.


% want to write something like:
% f = fst'{
% 0 1 The The
% 1 2 cat cat
% 2 3 sat sat
% 3 4 on on
% 4 5 the the
% 5 6 mat mat
% 6 !
% }.
%
% possibly matching the openfst file format? https://www.openfst.org/twiki/bin/view/FST/FstExamples


fst_str(X) = &error.