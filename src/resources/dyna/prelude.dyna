% :- export key/1.

% :- dispose key(quote1).
% :- make_system_term key/1.
% key(QuotedName) = $reflect(QuotedName, Dynabase, Name, _),
%                   $get_key_for_expression(Dynabase, Name, QuotedName).


:- export list/1.

% for annotation that somethign is a list.  This will match against all list types
list_rec([]).
list_rec([_|A]) :- list_rec(A).

% the "builtin" prelude is not allowed to be recursive, so this has to reference another function which is allowed to be recursive
% if the make_system_term is recursive, then it will cause the startup processes to crash
list(A) :- list_rec(A).
:- make_system_term list/1.  % set this after it is defined, as we can maybe want to enforce some error for this

:- export list/2.
:- dispose list(quote1, eval).  % this is going to quote the type argument, but if we make quoting something that is already hapening, then could this have some issue?

list_rec(Type, []).
list_rec(Type, [X|A]) :- Type(X), list_rec(Type, A).
list(Type, L) :- list_rec(Type, L).
:- make_system_term list/2.

:- export list_length/1.
:- export list_length/2.
list_length_rec([], 0).
list_length_rec([_|X], R+1) :- list_length_rec(X, R).

list_length(X) = list_length_rec(X, R), R.
list_length(X, R) :- list_length_rec(X, R).
:- make_system_term list_length/1.
:- make_system_term list_length/2.


:- export random/3.
:- export random/1.
:- export random/0.
random(Key, Lower, Upper) = (builtin_random_int32(Key) + 2147483648) / 4294967296.0 * (Upper - Lower) + Lower.
random(Key) = random(Key, 0, 1).

:- macro random/0.
random = `(random(*)).

:- macro random/2.
random(Lower, Upper) = `(random(*, Lower, Upper)).

:- make_system_term random/0.
:- make_system_term random/2.
:- make_system_term random/1.
:- make_system_term random/3.

% return the current random seed used by the system
$random_seed = $clojure'{
dyna.rexpr-builtins/random-seed
}.
:- make_system_term $random_seed/0.

$null = &$null.
:- make_system_term $null/0.


% this is the ?(foo(X)) operator right now.  But there is no support for that in the parser atm
% not sure if `?` should be given such a privileged position.  Also using `?` as the end of a query
:- macro is_defined/1.
is_defined(X) = `((|= false ; true for _ is `X)).

:- make_system_term is_defined/1.

:- macro $term/0.
$term = `(&$term(`(&$variable("$functor_name")), `(&$variable("$functor_arity")))).


% this is generated by the parser when doing something like X:int|string => X:$union_type(&int,&string) => $union_type(&int,&string,X), X
$union_type(A, B, Value) |= A(Value).
$union_type(A, B, Value) |= B(Value).
:- make_system_term $union_type/3.

% this isn't going to work, as this might indirect through multiple calls before it gets to final call.  In which case these extra variable names are going to get lost...
% I Suppose that there could be some extra variable like $meta or $call_from which could track this additional information?  Though not sure what the value would be.  In most cases
% it would probably just have that it would be null or not contain anything useful.

% :- macro $caller_file/0.
% :- macro $caller_name/0.
% :- macro $caller_arity/0.
% :- macro $caller_variables/0.
% $caller_file = &$variable("$1000000").   % these values should match in ast_to_rexpr.clj
% $caller_name = &$variable("$1000001").
% $caller_arity = &$variable("$1000002").
% $caller_variables = &$variable("$1000003").
% :- make_system_term $caller_file/0.
% :- make_system_term $caller_name/0.
% :- make_system_term $caller_arity/0.
% :- make_system_term $caller_variables/0.

:- macro $error/1.
%$error(Msg) = `(&$error(str(`(&$constant(str($caller_file, ": ", $caller_name, "/", $caller_arity, "   "))), `Msg))).
$error(Msg) = `(&$error(`Msg)).
:- make_system_term $error/1.



$get_key(X) := &$error("with_key not found on expression").
$get_key(&$with_key(R, K)) := K.

:- macro $arg/1.
$arg(X) := `($get_key($call_without_with_key(`X))).
$arg(&$variable(_)) := &$syntax_error("$arg can not be used on a variable, it must be used on the call directly, e.g. $arg(foo(1,2,3))").
$arg(&$constant(_)) := &$syntax_error("$arg can not be used on a constant").
:- make_system_term $arg/1.


% is is possible that this could get used somewhere that $with_key isn't present (e.g. if with_key was used on a dynabase which shared the name with something else).
% In this case, we have to handle that something might not unify with this expression.
$value(X) := X.
$value(&$with_key(R, K)) := R.
:- make_system_term $value/1.
